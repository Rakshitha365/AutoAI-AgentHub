"""
AutoAI Generated Streamlit Application

This application was automatically generated by the AutoAI Agent Framework.
Model: Ridge
Task: regression
Generated: 2025-10-15T11:03:13.142488

Author: AutoAI Agent Framework
Version: 1.0
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import os
from datetime import datetime

# Page configuration
st.set_page_config(
    page_title="AutoAI Model Demo",
    page_icon="🤖",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        margin: 0.5rem 0;
    }
    .success-card {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Header
st.markdown('<h1 class="main-header">🤖 AutoAI Model Demo</h1>', unsafe_allow_html=True)
st.markdown("---")

# Load model and preprocessor
try:
    model = joblib.load("artifacts\models\best_model_20251015110313.joblib")
    preprocessor = joblib.load("artifacts\models\preprocessor_20251015110313.joblib")
    st.sidebar.success("✅ Model and Preprocessor loaded successfully!")
except Exception as e:
    st.sidebar.error(f"❌ Error loading model or preprocessor: {e}")
    st.stop()

# Sidebar information
st.sidebar.header("📊 Model Information")
st.sidebar.markdown(f"**Model Type:** Ridge")
st.sidebar.markdown(f"**Task Type:** Regression")
st.sidebar.markdown(f"**Target Column:** target")
st.sidebar.markdown(f"**Generated:** 2025-10-15T11:03:13.142488")

# Display metrics
st.sidebar.header("📈 Performance Metrics")
metrics = {
    "mse": 1.1533,
    "rmse": 1.0739,
    "mae": 0.8194,
    "r2_score": -0.1016,
}
for metric, value in metrics.items():
    st.sidebar.metric(
        metric.replace('_', ' ').title(),
        f"{value:.4f}"
    )

st.sidebar.markdown("---")

# Main content
st.header("🎯 Make Predictions")
st.write("Enter the feature values below to get a prediction from the trained model.")

# Create input form
input_data = {}
col1, col2, col3 = st.columns(3)

# Generate input widgets based on feature names
for i, feature in enumerate(feature_names):
    current_col = [col1, col2, col3][i % 3]
    with current_col:
        # Determine input type based on feature name patterns
        if any(keyword in feature.lower() for keyword in ['age', 'year', 'count', 'number']):
            input_data[feature] = st.number_input(
                f"{feature.replace('_', ' ').title()}",
                min_value=0.0,
                max_value=1000.0,
                value=0.0,
                step=1.0,
                key=f"input_{feature}"
            )
        elif any(keyword in feature.lower() for keyword in ['rate', 'score', 'ratio', 'probability']):
            input_data[feature] = st.number_input(
                f"{feature.replace('_', ' ').title()}",
                min_value=0.0,
                max_value=1.0,
                value=0.5,
                step=0.01,
                key=f"input_{feature}"
            )
        else:
            input_data[feature] = st.number_input(
                f"{feature.replace('_', ' ').title()}",
                value=0.0,
                step=0.01,
                key=f"input_{feature}"
            )

# Prediction button
st.markdown("---")
col1, col2, col3 = st.columns([1, 2, 1])
with col2:
    if st.button("🔮 Make Prediction", type="primary", use_container_width=True):
        try:
            # Create DataFrame from input data
            input_df = pd.DataFrame([input_data])
            
            # Ensure all features are present and in correct order
            for feature in feature_names:
                if feature not in input_df.columns:
                    input_df[feature] = 0.0
            
            # Reorder columns to match training data
            input_df = input_df[feature_names]
            
            # Transform input data using preprocessor
            # Note: This assumes the preprocessor expects the original feature structure
            # For a robust solution, we would need to store the original feature mapping
            
            # Create a dummy DataFrame with original features for preprocessing
            # This is a simplified approach - in production, you'd want to store feature mapping
            original_features = ['feature_0', 'feature_3', 'feature_1_A', 'feature_1_B', 'feature_1_C', 'feature_2_0', 'feature_2_1', 'feature_4_A', 'feature_4_B', 'feature_4_C']  # Use feature names as original features
            
            # Create DataFrame with original feature structure
            processed_input_df = pd.DataFrame(columns=original_features)
            processed_input_df = pd.concat([processed_input_df, input_df], ignore_index=True).fillna(0)
            
            # Transform and predict
            transformed_input = preprocessor.transform(processed_input_df)
            prediction = model.predict(transformed_input)
            
            # Display results
            st.markdown("---")
            
            if task_type == "classification":
                prediction_text = f"Predicted Class: **{prediction[0]}**"
                st.markdown(f'<div class="success-card"><h3>🎯 {prediction_text}</h3></div>', unsafe_allow_html=True)
                
                # Show prediction probabilities if available
                if hasattr(model, 'predict_proba'):
                    probabilities = model.predict_proba(transformed_input)
                    st.subheader("📊 Prediction Probabilities")
                    
                    # Create probability chart
                    prob_df = pd.DataFrame(probabilities, columns=model.classes_)
                    st.bar_chart(prob_df.T)
                    
                    # Show probability table
                    st.subheader("📋 Detailed Probabilities")
                    for i, class_name in enumerate(model.classes_):
                        st.metric(f"Class {class_name}", f"{probabilities[0][i]:.4f}")
            else:
                prediction_text = f"Predicted Value: **{prediction[0]:.4f}**"
                st.markdown(f'<div class="success-card"><h3>🎯 {prediction_text}</h3></div>', unsafe_allow_html=True)
            
            # Show input summary
            with st.expander("📋 Input Summary"):
                st.json(input_data)
                
        except Exception as e:
            st.error(f"❌ Error making prediction: {str(e)}")
            st.exception(e)

# Footer
st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #666;'>
    <p>🤖 Generated by AutoAI Agent Framework | Version 1.0</p>
    <p>This application demonstrates automated ML model deployment</p>
</div>
""", unsafe_allow_html=True)

# Additional information
with st.expander("ℹ️ About This Model"):
    st.markdown(f"""
    **Model Details:**
    - **Algorithm:** Ridge
    - **Task Type:** regression
    - **Target Variable:** target
    - **Features:** 10 features
    - **Training Date:** 2025-10-15T11:03:13.142488
    
    **Performance Metrics:**
    """)
    for metric, value in metrics.items():
        st.write(f"- **{metric.replace('_', ' ').title()}:** {value:.4f}")
    
    st.markdown("""
    **How to Use:**
    1. Adjust the feature values in the input form above
    2. Click "Make Prediction" to get a prediction
    3. Review the results and probability distributions
    4. Experiment with different input combinations
    """)
